Problem:

Polycarp grew a tree from n vertices. We remind you that a tree of n vertices is an undirected connected graph of n vertices and nâˆ’1 edges that does not contain cycles.

He calls a set of vertices passable if there is such a path in the tree that passes through each vertex of this set without passing through any edge twice. The path can visit other vertices (not from this set).

In other words, a set of vertices is called passable if there is a simple path that passes through all the vertices of this set (and possibly some other).

For example, for a tree below sets {3,2,5}, {1,5,4}, {1,4} are passable, and {1,3,5}, {1,2,3,4,5} are not.

Polycarp asks you to answer q queries. Each query is a set of vertices. For each query, you need to determine whether the corresponding set of vertices is passable.

Link : https://codeforces.com/contest/1702/problem/G2


Solution in JAVA.

import java.util.*;
import java.lang.*;
import java.io.*;
 
 
public class Solution {
 
    static int MAX = 200005, DEPTH = 20;
 
    static List<Integer>[] graph = new List[MAX];
    static int[] depth = new int[MAX];
    static int[][] ancestor = new int[MAX][DEPTH];
 
    static int[] tin = new int[MAX];
    static int[] tout = new int[MAX];
    static int time = 1;
 
    public static void main(String[] args) throws java.lang.Exception {
        out = new PrintWriter(new BufferedOutputStream(System.out));
        sc = new FastReader();
 
        int test = 1;
        for (int t = 1; t <= test; t++) {
            solve(t);
        }
        out.close();
    }
 
    private static void solve(int t) {
        int n = sc.nextInt();
        initialize(n);
 
        for (int i = 0; i < n - 1; i++) {
            int u = sc.nextInt() - 1;
            int v = sc.nextInt() - 1;
            graph[u].add(v);
            graph[v].add(u);
        }
 
        dfs(0, 0);
 
        int q = sc.nextInt();
        for (int i = 0; i < q; i++) {
            int m = sc.nextInt();
            List<Integer> pathNodes = new ArrayList<>();
            for (int j = 0; j < m; j++) {
                int node = sc.nextInt() - 1;
                pathNodes.add(node);
            }
 
            pathNodes.sort((a, b) -> depth[b] - depth[a]);
 
            boolean[] onSimplePath = new boolean[m];
            int startNode = pathNodes.get(0);
            for (int j = 0; j < m; j++) {
                int currNode = pathNodes.get(j);
                if (LCA(startNode, currNode) == currNode) {
                    onSimplePath[j] = true;
                }
            }
 
            int endNodeIndex = 0;
            while (endNodeIndex < m && onSimplePath[endNodeIndex]) {
                endNodeIndex++;
            }
 
            if (endNodeIndex == m) {
                out.println("YES");
                continue;
            }
 
            int endNode = pathNodes.get(endNodeIndex);
            for (int j = endNodeIndex; j < m; j++) {
                int currNode = pathNodes.get(j);
                if (LCA(endNode, currNode) == currNode) {
                    onSimplePath[j] = true;
                }
            }
 
            boolean foundSimplePath = true;
            for (int j = 0; j < m; j++) {
                foundSimplePath &= onSimplePath[j];
            }
 
            foundSimplePath &= depth[LCA(startNode, endNode)] <= depth[pathNodes.get(m - 1)];
            out.println(foundSimplePath ? "YES" : "NO");
        }
    }
 
    private static void initialize(int n) {
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
            depth[i] = 0;
            tin[i] = 0;
            tout[i] = 0;
            time = 1;
            Arrays.fill(ancestor[i], 0);
        }
    }
 
    private static int LCA(int u, int v) {
        if (isAncestor(u, v)) {
            return u;
        }
        if (isAncestor(v, u)) {
            return v;
        }
        for (int i = DEPTH - 1; i >= 0; i--) {
            if (!isAncestor(ancestor[u][i], v)) {
                u = ancestor[u][i];
            }
        }
        return ancestor[u][0];
    }
 
    private static boolean isAncestor(int u, int v) {
        return tin[u] <= tin[v] && tout[u] >= tout[v];
    }
 
    private static void dfs(int currNode, int parent) {
        depth[currNode] = depth[parent] + 1;
        ancestor[currNode][0] = parent;
        tin[currNode] = time++;
        for (int i = 1; i < DEPTH; i++) {
            ancestor[currNode][i] = ancestor[ancestor[currNode][i - 1]][i - 1];
        }
        for (int adjacentNode : graph[currNode]) {
            if (adjacentNode == parent) {
                continue;
            }
            dfs(adjacentNode, currNode);
        }
        tout[currNode] = time++;
    }
 
 
    public static FastReader sc;
    public static PrintWriter out;
    static class FastReader
    {
        BufferedReader br;
        StringTokenizer str;
 
        public FastReader()
        {
            br = new BufferedReader(new
                    InputStreamReader(System.in));
        }
 
        String next()
        {
            while (str == null || !str.hasMoreElements())
            {
                try
 
                {
                    str = new StringTokenizer(br.readLine());
                }
                catch (IOException  lastMonthOfVacation)
                {
                    lastMonthOfVacation.printStackTrace();
                }
 
            }
            return str.nextToken();
        }
 
        int nextInt()
        {
            return Integer.parseInt(next());
        }
 
        long nextLong()
        {
            return Long.parseLong(next());
        }
 
        double nextDouble()
        {
            return Double.parseDouble(next());
        }
 
        String nextLine()
        {
            String str = "";
            try
            {
                str = br.readLine();
            }
            catch (IOException lastMonthOfVacation)
            {
                lastMonthOfVacation.printStackTrace();
            }
            return str;
        }
    }
 
}
